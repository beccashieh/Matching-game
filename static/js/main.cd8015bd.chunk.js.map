{"version":3,"sources":["components/nav.js","components/jumbotron.js","components/counter.js","components/image.js","App.js","serviceWorker.js","index.js"],"names":["Navbar","react_default","a","createElement","className","id","Jumbotron","Counter","props","score","topScore","Image","onClick","handleClick","src","link","alt","App","state","images","shuffleImages","currentIndex","length","randomIndex","Math","floor","random","tempValue","_this","setState","clickedNew","newItem","_this$state","newScore","newTopScore","item","console","log","clickedAgain","resetItem","map","image","Object","objectSpread","clicked","handleItemClick","correctGuess","clickedImages","this","_this2","nav","jumbotron","counter","components_image","key","Component","Boolean","window","location","hostname","match","ReactDOM","render","src_App_0","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.cd8015bd.chunk.js","sourcesContent":["import React from \"react\";\r\n\r\nfunction Navbar() {\r\n  return (\r\n    <div className=\"container\">\r\n      <nav className=\"navbar navbar-expand-lg navbar-light bg-light\">\r\n        <span className=\"navbar-brand\">\r\n          <h1>Memory Game</h1>\r\n        </span>\r\n        <div className=\"collapse navbar-collapse\" id=\"navbarNav\">\r\n          <ul className=\"navbar-nav ml-auto\">\r\n            <li className=\"nav-item\">\r\n              <span className=\"start-game-title\">\r\n                Click any image to start your game!\r\n              </span>\r\n            </li>\r\n          </ul>\r\n        </div>\r\n      </nav>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Navbar;\r\n","import React from \"react\";\r\n\r\nfunction Jumbotron() {\r\n  return (\r\n    <div className=\"container\">\r\n      <div className=\"jumbotron jumbotron-fluid text-center\">\r\n        <div className=\"container\">\r\n          <h1 className=\"display-4\">Memory Game:</h1>\r\n          <p className=\"lead\">\r\n            Click on an image to receive points, but don't click the same image twice!\r\n          </p>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Jumbotron;\r\n","import React from \"react\";\r\n\r\nfunction Counter (props) {\r\n  return(\r\n    <div className=\"counter card\" id=\"score-card\">\r\n    <h1 className=\"card-header\">Score Tally</h1>\r\n    <h3>\r\n      Score: {props.score}\r\n    </h3>\r\n    <hr></hr>\r\n    <h3>\r\n      Top Score: {props.topScore}\r\n    </h3>\r\n  </div>\r\n  )\r\n\r\n}\r\n\r\n\r\nexport default Counter;\r\n","import React from \"react\";\r\n\r\n//Image component creates each image card.\r\nfunction Image(props) {\r\n    return (\r\n        <div className=\"img-card\" onClick={ () => props.handleClick(props.id)}>\r\n          <div className=\"img-container\">\r\n            <img src={props.link} alt={props.id} />\r\n            <div className=\"card-body\"></div>\r\n          </div>\r\n        </div>\r\n      );\r\n};\r\n\r\n\r\nexport default Image;","import React, { Component } from \"react\";\n// import Wrapper from \"./components/wrapper\";\nimport Navbar from \"./components/nav\";\nimport Jumbotron from \"./components/jumbotron\";\nimport Counter from \"./components/counter\";\nimport Image from \"./components/image\";\nimport images from \"./images.json\";\nimport \"./App.css\";\n\nclass App extends Component {\n  //Sets this.state.images to the json array.\n  state = {\n    images,\n    score: 0,\n    topScore: 0\n  };\n\n  componentDidMount() {\n    this.setState({ images: this.shuffleImages(this.state.images) });\n  }\n\n  //Fischer-Yates algorithm to randomly shuffle images\n  shuffleImages = images => {\n    let currentIndex = images.length - 1;\n\n    while (currentIndex > 0) {\n      //Picks remaining element\n      const randomIndex = Math.floor(Math.random() * (currentIndex + 1));\n\n      //Swaps random element with current element\n      const tempValue = images[currentIndex];\n      images[currentIndex] = images[randomIndex];\n      images[randomIndex] = tempValue;\n      currentIndex--;\n    }\n\n    return images;\n  };\n  \n\n  //topScore function\n  //if user clicks same image, topScore reflects highest count and count returns to 0.\n  topScore = () => {\n    this.setState({\n      score: 0\n    })\n  };\n\n  //checks if the \"clicked\" property of the image is true. Should be changed once the user clicks on an image.\n  //if clicked is false, runs countIncrease.\n  //if clicked is true, runs topScore and resets the count.\n  clickedNew = (newItem) => {\n    // console.log(`Data id: ${data.id}\\n Data: ${id}`);\n    // this.countIncrease();\n    const { topScore, score } = this.state;\n    const newScore = score + 1;\n    const newTopScore = newScore > topScore ? newScore : topScore;\n    this.setState({\n      item: this.shuffleImages(newItem),\n      score: newScore,\n      topScore: newTopScore\n    });\n    console.log(\"Score: \", newScore);\n    console.log(\"Top Score: \", newTopScore);\n    // console.log('clicked', this.state.count);\n    // if (id !== data.id) {\n    //   this.countIncrease();\n    //   return this.state.count;\n    // }\n  };\n\n  clickedAgain = item => {\n    this.setState({\n      item: this.resetItem(item),\n      score: 0,\n    })\n    console.log('clicked again');\n    // if (id === data.id) {\n    //   console.log('You chose a card more than once.')\n    //   this.topScore();\n    // }\n  }\n\n  resetItem = item => {\n    const resetItem = item.map(image => ({...item, clicked: false}));\n    return this.shuffleImages(resetItem);\n  }\n\n  // handleChange = event => {\n  //   //Changes the clicked boolean to true.\n  //   this.setState({\n  //     clicked: true\n  //   });\n  //   this.shuffleImages(images);\n  // };\n\n  handleItemClick = id => {\n    let correctGuess= false;\n    const clickedImages = this.state.images.map(item => {\n      const newItem = {...item};\n      if (newItem.id === id){\n        if (!newItem.clicked) {\n          \n          newItem.clicked = true;\n          correctGuess = true;\n          console.log(\"correct\",correctGuess);\n        }\n      }\n      return newItem;\n    });\n   \n    if (correctGuess){\n      console.log('if');\n      this.clickedNew(clickedImages);\n      // console.log('you clicked a new image');\n    } \n    else {\n      console.log('else ', clickedImages);\n      this.clickedAgain(clickedImages);\n      // console.log('you chose this image already');\n    }\n\n    // this.setState({\n    //   images: this.shuffleImages(images)\n    // });\n    // console.log(`Score: ${this.state.score} Top Score: ${this.state.topScore}`);\n  };\n  \n\n  render() {\n    return (\n      <div className=\"container\">\n        <Navbar />\n        <Jumbotron />\n        <Counter\n          score={this.state.score}\n          topScore={this.state.topScore}/>\n        <div className=\"images-section\" id=\"imgSection\">\n          {this.state.images.map(image => (\n            <Image\n              // handleChange={this.handleChange}\n              id={image.id}\n              key={image.id}\n              link={image.link}\n              handleClick={this.handleItemClick}\n              // onClick={this.countIncrease}\n            />\n          ))}\n        </div>\n        <footer>\n          Memory Game with React\n          <i className=\"fab fa-react\" />\n        </footer>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n    window.location.hostname === 'localhost' ||\r\n      // [::1] is the IPv6 localhost address.\r\n      window.location.hostname === '[::1]' ||\r\n      // 127.0.0.1/8 is considered localhost for IPv4.\r\n      window.location.hostname.match(\r\n        /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n      )\r\n  );\r\n  \r\n  export function register(config) {\r\n    if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n      // The URL constructor is available in all browsers that support SW.\r\n      const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n      if (publicUrl.origin !== window.location.origin) {\r\n        // Our service worker won't work if PUBLIC_URL is on a different origin\r\n        // from what our page is served on. This might happen if a CDN is used to\r\n        // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n        return;\r\n      }\r\n  \r\n      window.addEventListener('load', () => {\r\n        const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n  \r\n        if (isLocalhost) {\r\n          // This is running on localhost. Let's check if a service worker still exists or not.\r\n          checkValidServiceWorker(swUrl, config);\r\n  \r\n          // Add some additional logging to localhost, pointing developers to the\r\n          // service worker/PWA documentation.\r\n          navigator.serviceWorker.ready.then(() => {\r\n            console.log(\r\n              'This web app is being served cache-first by a service ' +\r\n                'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n            );\r\n          });\r\n        } else {\r\n          // Is not localhost. Just register service worker\r\n          registerValidSW(swUrl, config);\r\n        }\r\n      });\r\n    }\r\n  }\r\n  \r\n  function registerValidSW(swUrl, config) {\r\n    navigator.serviceWorker\r\n      .register(swUrl)\r\n      .then(registration => {\r\n        registration.onupdatefound = () => {\r\n          const installingWorker = registration.installing;\r\n          if (installingWorker == null) {\r\n            return;\r\n          }\r\n          installingWorker.onstatechange = () => {\r\n            if (installingWorker.state === 'installed') {\r\n              if (navigator.serviceWorker.controller) {\r\n                // At this point, the updated precached content has been fetched,\r\n                // but the previous service worker will still serve the older\r\n                // content until all client tabs are closed.\r\n                console.log(\r\n                  'New content is available and will be used when all ' +\r\n                    'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n                );\r\n  \r\n                // Execute callback\r\n                if (config && config.onUpdate) {\r\n                  config.onUpdate(registration);\r\n                }\r\n              } else {\r\n                // At this point, everything has been precached.\r\n                // It's the perfect time to display a\r\n                // \"Content is cached for offline use.\" message.\r\n                console.log('Content is cached for offline use.');\r\n  \r\n                // Execute callback\r\n                if (config && config.onSuccess) {\r\n                  config.onSuccess(registration);\r\n                }\r\n              }\r\n            }\r\n          };\r\n        };\r\n      })\r\n      .catch(error => {\r\n        console.error('Error during service worker registration:', error);\r\n      });\r\n  }\r\n  \r\n  function checkValidServiceWorker(swUrl, config) {\r\n    // Check if the service worker can be found. If it can't reload the page.\r\n    fetch(swUrl)\r\n      .then(response => {\r\n        // Ensure service worker exists, and that we really are getting a JS file.\r\n        const contentType = response.headers.get('content-type');\r\n        if (\r\n          response.status === 404 ||\r\n          (contentType != null && contentType.indexOf('javascript') === -1)\r\n        ) {\r\n          // No service worker found. Probably a different app. Reload the page.\r\n          navigator.serviceWorker.ready.then(registration => {\r\n            registration.unregister().then(() => {\r\n              window.location.reload();\r\n            });\r\n          });\r\n        } else {\r\n          // Service worker found. Proceed as normal.\r\n          registerValidSW(swUrl, config);\r\n        }\r\n      })\r\n      .catch(() => {\r\n        console.log(\r\n          'No internet connection found. App is running in offline mode.'\r\n        );\r\n      });\r\n  }\r\n  \r\n  export function unregister() {\r\n    if ('serviceWorker' in navigator) {\r\n      navigator.serviceWorker.ready.then(registration => {\r\n        registration.unregister();\r\n      });\r\n    }\r\n  }","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}